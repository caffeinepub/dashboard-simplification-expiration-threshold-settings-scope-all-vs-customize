{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Instant Dashboard documents refresh via React Query export-data query + centralized invalidation",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Refactor DashboardPage documents data loading to use a React Query hook with a stable queryKey instead of local state + one-time manual fetch.",
      "acceptanceCriteria": [
        "DashboardPage no longer relies on local useState + useEffect to call actor.exportData() for documents/bench data; it uses a React Query hook with a stable queryKey.",
        "The dashboard documents list is sourced from the React Query cache and updates after a refetch without requiring a full page reload."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/DashboardPage.tsx",
          "operation": "modify",
          "description": "Replace the local useState/useEffect fetch of actor.getAllTestBenches() + actor.exportData() with the shared React Query hook (e.g., useDashboardExportData) and source benches/documents/components/history from the query result so the documents section updates from cache after invalidation/refetch."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Introduce a dedicated reusable React Query hook for dashboard/export data with a single well-defined queryKey suitable for invalidation.",
      "acceptanceCriteria": [
        "A reusable hook exists in frontend/src/hooks/useQueries.ts (or a nearby non-immutable hook file) that fetches the dashboard/export payload and exposes loading/error state.",
        "The hook uses a single, well-defined queryKey (e.g., ['dashboardExportData'] or similar) so other mutations can invalidate it."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Add a new React Query hook (e.g., useDashboardExportData) that wraps actor.exportData() and any dependent calls (e.g., actor.getAllTestBenches()) into one query with a stable shared queryKey (e.g., ['dashboardExportData']). Also export the queryKey (or a small helper) for consistent reuse by mutation hooks."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Centrally invalidate the dashboard/export data React Query cache after any document/bench-document mutations so Dashboard updates immediately without reload.",
      "acceptanceCriteria": [
        "After uploading a document and associating it to a bench (BenchDocumentsEditor), navigating to (or already viewing) the Dashboard shows the correct updated assigned benches for that document without manual reload.",
        "After deleting, duplicating, or editing a bench document, the Dashboard documents list reflects the change after the mutation completes (no stale association list).",
        "React Query invalidation is implemented centrally in the relevant mutation hooks (e.g., useAssociateDocumentToBench, useRemoveDocumentFromBench, useEditBenchDocument, useDuplicateBenchDocument, useDeleteBenchDocument) by invalidating the dashboard/export queryKey in addition to existing per-bench invalidations."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Update document + bench-document mutation hooks to invalidate the shared dashboard/export queryKey on success (in addition to existing per-bench invalidations): useAssociateDocumentToBench, useRemoveDocumentFromBench, useEditBenchDocument, useDuplicateBenchDocument, useDeleteBenchDocument. If any document creation/upload is performed outside a mutation hook, add a dedicated mutation hook (e.g., useCreateDocument) that also invalidates the same queryKey so upload+associate flows can invalidate consistently."
        },
        {
          "path": "frontend/src/pages/Benches/components/DuplicateDocumentDialog.tsx",
          "operation": "modify",
          "description": "Ensure the duplicate flow relies on the updated useDuplicateBenchDocument invalidation behavior and does not add any manual dashboard refresh logic; keep UI behavior unchanged while benefiting from centralized query invalidation."
        },
        {
          "path": "frontend/src/pages/Benches/components/EditBenchDocumentDialog.tsx",
          "operation": "modify",
          "description": "Ensure the edit flow relies on the updated useEditBenchDocument invalidation behavior and does not add any manual dashboard refresh logic; keep UI behavior unchanged while benefiting from centralized query invalidation."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Refactor BenchDocumentsEditor to consume React Query data and trigger refresh via invalidation/refetch rather than re-calling actor.exportData() into local state.",
      "acceptanceCriteria": [
        "BenchDocumentsEditor triggers refresh through React Query (either by using queryClient.invalidateQueries for the dashboard/export query and/or by consuming the shared query directly), rather than depending solely on re-calling actor.exportData() into local state.",
        "No additional user action (refresh button, page reload) is required for the dashboard’s document-to-bench mapping to become correct after performing document operations in the benches UI."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/Benches/components/BenchDocumentsEditor.tsx",
          "operation": "modify",
          "description": "Remove the local loadDocuments() implementation that calls actor.exportData() and instead derive the bench-specific document list from the shared React Query dashboard/export data hook (filter by associatedBenches.includes(benchId)). After upload+associate and other document operations, rely on the mutation hooks’ centralized query invalidation (and optionally a targeted invalidateQueries call) so the editor and dashboard stay consistent without manual reload."
        }
      ]
    }
  ]
}