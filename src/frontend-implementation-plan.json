{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Profile enhancements, configurable email domain validation, improved bench documents UX, unified drag-and-drop layouts, admin entity/online status, and UI fixes",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Add profile picture selection (custom upload or predefined avatars) and an editable Entity field on the profile, persisted via backend-backed profile data.",
      "acceptanceCriteria": [
        "Profile page shows an avatar section with (1) upload control and (2) selectable predefined avatars.",
        "User can save either an uploaded photo or a predefined avatar selection and see it persist after reload.",
        "Profile data model includes an Entity string field; Profile page allows editing it and persists it.",
        "All new/updated user-facing UI text for this feature is in English."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/ProfilePage.tsx",
          "operation": "modify",
          "description": "Add an Avatar section that supports (a) custom photo upload and (b) predefined avatar selection; add an editable Entity input; persist changes by calling backend capabilities uploadProfilePicture/setProfilePicture and saveCallerUserProfile. Use the blob-storage ExternalBlob client type for custom image upload/display and keep all new UI text in English. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/profile/PredefinedAvatarPicker.tsx",
          "operation": "create",
          "description": "Create a small picker component to render selectable predefined avatars (duck/basketball/rocket/robot) and return the selected avatar id for Profile picture selection. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/public/assets/avatars/duck.svg",
          "operation": "create",
          "description": "Add a lightweight local SVG avatar asset for the 'duck' predefined avatar option."
        },
        {
          "path": "frontend/public/assets/avatars/basketball.svg",
          "operation": "create",
          "description": "Add a lightweight local SVG avatar asset for the 'basketball' predefined avatar option."
        },
        {
          "path": "frontend/public/assets/avatars/rocket.svg",
          "operation": "create",
          "description": "Add a lightweight local SVG avatar asset for the 'rocket' predefined avatar option."
        },
        {
          "path": "frontend/public/assets/avatars/robot.svg",
          "operation": "create",
          "description": "Add a lightweight local SVG avatar asset for the 'robot' predefined avatar option."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Enforce a configurable corporate email domain when saving a profile email, and expose an Admin setting to update the enforced domain.",
      "acceptanceCriteria": [
        "When a non-admin user attempts to save a profile email that does not match the currently configured domain, the save is rejected with an English validation error message.",
        "Admin UI includes a setting to view and update the enforced email domain.",
        "Backend stores the enforced domain and applies it to profile email updates consistently.",
        "The default enforced domain is 'safrangroup.com' if no admin override has been set."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Add React Query hooks to fetch and update the enforced email domain using backend capabilities getAllowedEmailDomain and setAllowedEmailDomain; expose hook(s) to check admin status/role for UI-side enforcement/guarding. Verify the component's usage instructions before implementing (authorization)."
        },
        {
          "path": "frontend/src/utils/validation.ts",
          "operation": "modify",
          "description": "Add a validation helper for enforcing an allowed email domain (e.g., validateEmailAgainstDomain(email, allowedDomain)) that returns an English error message when domain mismatches."
        },
        {
          "path": "frontend/src/pages/ProfilePage.tsx",
          "operation": "modify",
          "description": "On profile save, fetch the current allowed email domain and enforce it for non-admin users; reject save with a clear English validation error if the domain does not match."
        },
        {
          "path": "frontend/src/pages/Admin/components/AdminEmailDomainSettingsPanel.tsx",
          "operation": "create",
          "description": "Create an admin-only settings panel to display and update the enforced email domain value using the get/set domain hooks; keep all labels and errors in English. Verify the component's usage instructions before implementing (authorization)."
        },
        {
          "path": "frontend/src/pages/Admin/AdminPage.tsx",
          "operation": "modify",
          "description": "Wire the new AdminEmailDomainSettingsPanel into the Admin page layout so admins can view/update the enforced email domain."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Improve Bench Documents UX to support per-category '+' add, and per-document delete, edit/replace, and download actions across HW/SW/Other sections.",
      "acceptanceCriteria": [
        "Bench detail Documents tab shows HW/SW/Other sections each with a visible '+' action to add a document.",
        "Each document row shows delete, edit/replace, and download actions and they work end-to-end.",
        "Replacing a document updates the stored file while keeping the document entry coherent (no duplicate/ghost entries after replace).",
        "All user-facing labels/tooltips for document actions are in English."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/Benches/components/BenchDocumentsEditor.tsx",
          "operation": "modify",
          "description": "Refactor the documents UI to show Hardware/Software/Other(s) sections each with a visible '+' action to add a document directly within that category. For each document row, add actions: delete (trash), edit/replace (pencil toggle to reveal a replace file input + confirm/cancel), and download. Implement replace by creating a new document and associating it to the bench, then removing the old association to avoid duplicates/ghost entries; keep all labels/tooltips in English. Verify the component's usage instructions before implementing (blob-storage ExternalBlob)."
        },
        {
          "path": "frontend/src/utils/download.ts",
          "operation": "modify",
          "description": "Ensure the download helper supports the updated document action flows reliably (e.g., consistent filename handling and error propagation) used by BenchDocumentsEditor."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Unify drag-and-drop layout reordering across all tabs and improve Admin tab drag UX (handles, spacing, feedback) using a consistent interaction pattern.",
      "acceptanceCriteria": [
        "All tabs that present layout blocks allow reordering via drag-and-drop (not only a subset).",
        "Drag interaction patterns are consistent across tabs (same handle/hover/active states).",
        "Admin tab layout reordering UX is visually consistent and clearer than before (handle visibility + drop indicator)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/dnd/DraggableList.tsx",
          "operation": "create",
          "description": "Create a reusable drag-and-drop list component (HTML5 drag events) that provides consistent handle, hover/active states, and a clear drop indicator for reordering layout blocks. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/dnd/useDraggableOrder.ts",
          "operation": "create",
          "description": "Create a small hook to manage in-memory reorder state and emit updated orders to callers (e.g., for persistence). Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/pages/DashboardPage.tsx",
          "operation": "modify",
          "description": "Replace the current up/down reorder controls for dashboard sections with the unified DraggableList behavior, keeping persistence via the existing backend-backed dashboardSectionsOrdered save capability; ensure consistent drag handle and feedback."
        },
        {
          "path": "frontend/src/pages/Admin/AdminPage.tsx",
          "operation": "modify",
          "description": "Wrap Admin panels in the shared draggable layout system so admins can reorder the Admin tab panels with consistent handles/spacing/feedback (and improved clarity vs current behavior). Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/pages/Benches/BenchDetailPage.tsx",
          "operation": "modify",
          "description": "Identify any layout-block areas within Bench Detail tabs (e.g., card blocks inside tabs) and apply the same DraggableList behavior wherever layout blocks are presented so reordering is not limited to a subset of tabs. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/index.css",
          "operation": "modify",
          "description": "Add minimal global styling utilities/classes (outside of immutable UI component paths) to support consistent drag handle affordance and drop indicator visuals across pages, compatible with light/dark themes."
        }
      ]
    },
    {
      "id": "REQ-5",
      "summary": "Add Admin entity selector and filtering to list users belonging to the selected entity, including an English empty state.",
      "acceptanceCriteria": [
        "Admin page includes an Entity selector listing all entities known to the system (not only those currently filtered/visible).",
        "Selecting an entity updates the displayed user list to only members of that entity.",
        "If an entity has no users, the UI shows an English empty state."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Add hooks to load all entities and users by selected entity using backend capabilities getAllEntities and getUsersByEntity; ensure query keys are entity-specific for proper caching/invalidation. Verify the component's usage instructions before implementing (authorization)."
        },
        {
          "path": "frontend/src/pages/Admin/components/AdminUsersPanel.tsx",
          "operation": "modify",
          "description": "Extend the Admin Users panel to include an Entity dropdown listing all entities from the system, and display only the users for the selected entity. Add an English empty state for entities with no users. Verify the component's usage instructions before implementing (authorization)."
        }
      ]
    },
    {
      "id": "REQ-6",
      "summary": "Show online/offline status dots for users in Admin entity user list, based on last-seen timestamps updated periodically by the authenticated frontend (no sockets).",
      "acceptanceCriteria": [
        "Each listed user in Admin shows a green or red dot status indicator.",
        "Status determination is based on a stored last-seen timestamp and a defined threshold (e.g., within the last N minutes = online).",
        "Frontend updates last-seen periodically while the user remains signed in, and stops when signed out.",
        "No WebSockets or third-party real-time services are used."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useLastSeenHeartbeat.ts",
          "operation": "create",
          "description": "Create a hook that, while authenticated, periodically calls the backend capability updateLastSeen on an interval; ensure it starts/stops based on authentication state and is resilient to actor/identity changes. Verify the component's usage instructions before implementing (authorization)."
        },
        {
          "path": "frontend/src/components/layout/AppShell.tsx",
          "operation": "modify",
          "description": "Install the last-seen heartbeat hook so lastSeen updates run only while the user is signed in, and stop on sign-out (clearing queries already happens on logout). Verify the component's usage instructions before implementing (authorization)."
        },
        {
          "path": "frontend/src/pages/Admin/components/AdminUsersPanel.tsx",
          "operation": "modify",
          "description": "Compute online/offline from each user's lastSeen timestamp using a defined threshold (e.g., lastSeen within N minutes => online) and render a green/red dot next to each user in the selected entity list; keep labels/tooltips in English."
        }
      ]
    },
    {
      "id": "REQ-7",
      "summary": "Replace the current app logo with the provided Safran logo and ensure correct rendering in both light and dark themes.",
      "acceptanceCriteria": [
        "The app header/navigation uses the Safran logo asset instead of the previous logo.",
        "Logo appears crisp at common header sizes and does not distort.",
        "Logo remains legible/appropriate in both light and dark mode."
      ],
      "file_operations": [
        {
          "path": "frontend/public/assets/SAF.PA_BIG-99558ca4.png",
          "operation": "create",
          "description": "Add the provided Safran logo image to the frontend public assets for use in the application header."
        },
        {
          "path": "frontend/src/components/layout/AppShell.tsx",
          "operation": "modify",
          "description": "Update the header logo to use the Safran logo asset from frontend/public/assets/SAF.PA_BIG-99558ca4.png, set sizing to avoid distortion, and apply light/dark theme-friendly styling so it remains legible in both modes."
        }
      ]
    },
    {
      "id": "REQ-8",
      "summary": "Fix header overlapping content in light mode by keeping the header fixed with a white background and offsetting main content appropriately across primary routes.",
      "acceptanceCriteria": [
        "In light mode, the header remains fixed during scroll and has a white background.",
        "No page content is hidden behind the header in any primary route (Dashboard, Benches list/detail, Admin, Profile)."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/layout/AppShell.tsx",
          "operation": "modify",
          "description": "Change the header to fixed positioning (or equivalent) with a white background in light mode, and update the main content container padding/margin so content never renders beneath the header across all routes."
        },
        {
          "path": "frontend/src/index.css",
          "operation": "modify",
          "description": "If needed, add/adjust global CSS variables/utilities to standardize header height offsets in a theme-safe way (light mode white header; dark mode consistent with existing theme tokens)."
        }
      ]
    },
    {
      "id": "REQ-9",
      "summary": "Add contextual scroll shortcuts: show scroll-to-bottom near the top and scroll-to-top near the bottom, with smooth scrolling and keyboard accessibility.",
      "acceptanceCriteria": [
        "A scroll-to-bottom control appears when the user is near the top; clicking scrolls smoothly to the bottom.",
        "A scroll-to-top control appears when the user is near the bottom; clicking scrolls smoothly to the top.",
        "Controls do not obstruct important UI elements and are keyboard accessible."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/navigation/ScrollShortcuts.tsx",
          "operation": "create",
          "description": "Create a component that listens to scroll position and conditionally shows keyboard-accessible buttons for 'Scroll to bottom' (near top) and 'Scroll to top' (near bottom), using smooth scrolling and non-obstructive placement."
        },
        {
          "path": "frontend/src/components/layout/AppShell.tsx",
          "operation": "modify",
          "description": "Wire ScrollShortcuts into the authenticated app shell so it is available across primary routes without adding new routes."
        }
      ]
    },
    {
      "id": "REQ-10",
      "summary": "Enable drag-and-drop reordering of all internal layouts within the Statistics area (not only the overall Statistics block), with persistence after refresh for the same user.",
      "acceptanceCriteria": [
        "Within the Statistics area, individual chart/layout cards can be reordered via drag-and-drop.",
        "The order persists after refresh for the same user."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/Dashboard/components/StatisticsSection.tsx",
          "operation": "create",
          "description": "Extract the Statistics section into its own component with an internal draggable list of statistic cards using the shared DraggableList behavior; persist internal order in localStorage (user-scoped key) so it survives refresh. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/pages/DashboardPage.tsx",
          "operation": "modify",
          "description": "Replace the inline Statistics rendering with the new StatisticsSection component, ensuring it participates in the page's layout system and does not break existing dashboard functionality."
        }
      ]
    },
    {
      "id": "REQ-11",
      "summary": "Add two draggable Statistics chart cards with filters: estimated components by criticality and by deadline/date limite.",
      "acceptanceCriteria": [
        "Statistics page shows two distinct chart cards: by criticality and by deadline/date limite.",
        "Each chart includes filters that affect the displayed aggregation.",
        "Both chart cards participate in the internal Statistics drag-and-drop reorder system."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/Dashboard/components/StatisticsCharts/CriticalityChartCard.tsx",
          "operation": "create",
          "description": "Create a chart card that estimates number of components by criticality (e.g., OK/Expiring soon/Expired based on existing computed statuses) and provides filters that change the aggregation; keep all UI text in English."
        },
        {
          "path": "frontend/src/pages/Dashboard/components/StatisticsCharts/DeadlineChartCard.tsx",
          "operation": "create",
          "description": "Create a chart card that estimates number of components by deadline/date limite (e.g., group by time buckets derived from expirationDate) and provides filters that change the aggregation; keep all UI text in English."
        },
        {
          "path": "frontend/src/pages/Dashboard/components/StatisticsSection.tsx",
          "operation": "modify",
          "description": "Wire the two new chart cards into the StatisticsSection internal draggable layout list so both cards are reorderable and participate in the persisted internal order. Verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-12",
      "summary": "Only show the PLM Agile URL shortcut on bench cards when the Agile URL exists; hide the shortcut container when missing/empty.",
      "acceptanceCriteria": [
        "Bench cards with an Agile URL show a visible shortcut link under the image.",
        "Bench cards without an Agile URL do not show any placeholder/link container."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/Benches/BenchListPage.tsx",
          "operation": "modify",
          "description": "Harden the conditional rendering for the PLM Agile URL shortcut to treat empty/whitespace-only values as missing, ensuring no placeholder container renders when absent."
        }
      ]
    },
    {
      "id": "REQ-13",
      "summary": "Add a deterministic, fully client-side heuristic Rewrite button for the bench description in the bench creation form (no external AI services).",
      "acceptanceCriteria": [
        "Description field has a Rewrite button that updates the text using local heuristics only.",
        "The rewrite operation is deterministic and runs fully client-side.",
        "UI text (button label, helper text) is in English."
      ],
      "file_operations": [
        {
          "path": "frontend/src/utils/rewriteDescription.ts",
          "operation": "create",
          "description": "Implement a deterministic client-side heuristic rewrite function for bench descriptions (e.g., whitespace cleanup, sentence casing, common phrasing normalization) with no external calls."
        },
        {
          "path": "frontend/src/pages/Benches/components/AddBenchModal.tsx",
          "operation": "modify",
          "description": "Add a 'Rewrite' button in the Description section that applies the local rewrite utility to the current description value; keep all labels/helper text in English and ensure behavior is deterministic."
        }
      ]
    }
  ]
}